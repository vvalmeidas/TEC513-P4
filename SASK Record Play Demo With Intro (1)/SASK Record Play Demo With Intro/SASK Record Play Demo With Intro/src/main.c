/**********************************************************************
* © 2007 Microchip Technology Inc.
*
* FileName:        main.c
* Dependencies:    Header (.h) files if applicable, see below
* Processor:       dsPIC33FJ256GP506
* Compiler:        MPLAB® C30 v3.00 or higher
*
*SOFTWARE LICENSE AGREEMENT:
*Except as otherwise expressly provided below, Microchip Technology Inc. 
*(Microchip) licenses this software to you solely for use with Microchip products.
*This software is owned by Microchip and/or its licensors, and is protected under 
*applicable copyright laws.  All rights reserved.
*
*This software and any accompanying information is for suggestion only.  
*It shall not be deemed to modify Microchip?s standard warranty for its products.
*It is your responsibility to ensure that this software meets your requirements.
*
*WARRANTY DISCLAIMER AND LIMIT ON LIABILITY:  SOFTWARE IS PROVIDED AS IS.  
*MICROCHIP AND ITS LICENSORS EXPRESSLY DISCLAIM ANY WARRANTY OF ANY KIND, 
*WHETHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
*OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. 
*IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE FOR ANY INCIDENTAL, 
*SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, 
*HARM TO YOUR EQUIPMENT, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY 
*OR SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY 
*DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER SIMILAR 
*COSTS.  To the fullest extend allowed by law, Microchip and its licensors 
*liability shall not exceed the amount of fees, if any, that you have paid 
*directly to Microchip to use this software.
*
*THIRD PARTY SOFTWARE:  Notwithstanding anything to the contrary, any third 
*party software accompanying this software including but not limited to ITU 
*software is subject to the terms and conditions of the third party?s license
*agreement such as the General Public License.  To the extent required by third
*party licenses covering such third party software, the terms of such license 
*will apply in lieu of the terms provided herein.  To the extent the terms of 
*such third party licenses prohibit any of the restrictions described herein, 
*such restrictions will not apply to such third party software.  THIRD PARTY 
*SOFTWARE  IS SUBJECT TO THE FOREGOING WARRANTY DISCLAIMER AND LIMIT ON LIABILITY 
*PROVIDED IN THE PARAGRAPH ABOVE
*
*MICROCHIP PROVIDES THIS SOFTWARE (INCLUDING ACCOMPANYING THIRD PARTY SOFTWARE)
*CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
************************************************************************/

#include <p33FJ256GP506.h>
#include "..\h\OCPWMDrv.h"
#include "..\h\sask.h"
#include "..\h\SFMDrv.h"
#include "..\h\G711.h"
#include "..\h\ADCChannelDrv.h"
#include <stdio.h>
#include <math.h>

#define SIZE 10
#define SIZE_FILTER 94
_FGS(GWRP_OFF & GCP_OFF);
_FOSCSEL(FNOSC_FRC);
_FOSC(FCKSM_CSECMD & OSCIOFNC_ON & POSCMD_NONE);
_FWDT(FWDTEN_OFF);

/* FRAME_SIZE - Size of each audio frame 	
 * SPEECH_SEGMENT_SIZE - Size of intro speech segment
 * WRITE_START_ADDRESS - Serial Flash Memory write address					
 * */

#define FRAME_SIZE 				128			
#define SPEECH_SEGMENT_SIZE		98049L		
#define WRITE_START_ADDRESS	0x20000	
#define FILTER_SIZE 71
#define SAMPLE_SIZE FRAME_SIZE - FILTER_SIZE + 1


//headers
void convolution(int signal[], float kernel[], int result[], int size_signal, int size_kernel, int size_result);

/* Allocate memory for buffers and drivers	*/

int		adcBuffer		[ADC_CHANNEL_DMA_BUFSIZE] 	__attribute__((space(dma)));
int		ocPWMBuffer		[OCPWM_DMA_BUFSIZE]		__attribute__((space(dma)));
int		samples			[SAMPLE_SIZE];
char 	encodedSamples	[FRAME_SIZE];
int 	decodedSamples	[FRAME_SIZE];
char 	flashMemoryBuffer	[SFMDRV_BUFFER_SIZE];

//int 	output	[FRAME_SIZE + FILTER_SIZE - 1];
int 	output	[FRAME_SIZE];

/* Instantiate the drivers 	*/
ADCChannelHandle adcChannelHandle;
OCPWMHandle 	ocPWMHandle;

/* Create the driver handles	*/
ADCChannelHandle *pADCChannelHandle 	= &adcChannelHandle;
OCPWMHandle 	*pOCPWMHandle 		= &ocPWMHandle;

/* Addresses 
 * currentReadAddress - This one tracks the intro message	
 * currentWriteAddress - This one tracks the writes to flash	
 * userPlaybackAddress - This one tracks user playback		
 * address - Used during flash erase
 * */

 long currentReadAddress;		
 long currentWriteAddress;		
 long userPlaybackAddress;
 long address;	
 
 /* flags
 * record - if set means recording
 * playback - if set mean playback
 * erasedBeforeRecord - means SFM eras complete before record
 * */	

int record;						
int playback;						
int erasedBeforeRecord;			

int main(void)
{
	/* Addresses 
	 * currentReadAddress - This one tracks the intro message	
	 * currentWriteAddress - This one tracks the writes to flash	
	 * userPlaybackAddress - This one tracks user playback		
	 * address - Used during flash erase
	 * */

	long currentReadAddress = 0;		
	long currentWriteAddress = WRITE_START_ADDRESS;		
	long userPlaybackAddress = WRITE_START_ADDRESS;		
	long address = 0;	
    
    
	/* flags
	 * record - if set means recording
	 * playback - if set mean playback
	 * erasedBeforeRecord - means SFM eras complete before record
	 * */

//	int record = 0;						
//	int playback = 0;					
//	int erasedBeforeRecord = 0;			

	/* Configure Oscillator to operate the device at 40MHz.
	 * Fosc= Fin*M/(N1*N2), Fcy=Fosc/2
	 * Fosc= 7.37M*40/(2*2)=80Mhz for 7.37M input clock */
	 
	PLLFBD=41;				/* M=39	*/
	CLKDIVbits.PLLPOST=0;		/* N1=2	*/
	CLKDIVbits.PLLPRE=0;		/* N2=2	*/
	OSCTUN=0;			
	
	__builtin_write_OSCCONH(0x01);		/*	Initiate Clock Switch to FRC with PLL*/
	__builtin_write_OSCCONL(0x01);
	while (OSCCONbits.COSC != 0b01);	/*	Wait for Clock switch to occur	*/
	while(!OSCCONbits.LOCK);

	
	/* Intialize the board and the drivers	*/
//	SASKInit();
	ADCChannelInit	(pADCChannelHandle,adcBuffer);			/* For the ADC	*/
	OCPWMInit		(pOCPWMHandle,ocPWMBuffer);			/* For the OCPWM	*/

	/* Open the flash and unprotect it so that
	 * it can be written to.
	 * */

	SFMInit(flashMemoryBuffer);
	
		
	/* Start Audio input and output function	*/
	ADCChannelStart	(pADCChannelHandle);
	OCPWMStart		(pOCPWMHandle);	
		
	
	/* Main processing loop. Executed for every input and 
	 * output frame	*/
    //int kernel[] = {1};
    
    //BandPass ->  Comprimento = 131
    //float kernel[SIZE_FILTER] = {-6.45212572241339e-05,0.000148611327942570,0.000455975615898701,0.000767124547972938,0.000964372863688596,0.000954165973571452,0.000718905391650965,0.000342823119396256,-7.11517274279584e-06,-0.000145791262226558,4.19901957069140e-05,0.000528020447770132,0.00112047634865747,0.00151760259655791,0.00142457039290806,0.000690844072358443,-0.000592087600030799,-0.00208503638292099,-0.00330641071314688,-0.00381950579002927,-0.00343041867033748,-0.00230873940162444,-0.000964177179142884,-6.69044362889647e-05,-0.000167873321602377,-0.00142876780031817,-0.00348338043361511,-0.00551171810403988,-0.00652571461056274,-0.00577188463884746,-0.00309148807118669,0.000924775470203202,0.00508316099389093,0.00801189606776569,0.00871848331722897,0.00705638445553241,0.00388808292184370,0.000834459803458931,-0.000336309994306555,0.00153395497279256,0.00639415629597769,0.0128186591434363,0.0184036150487904,0.0206318293511634,0.0179044612984461,0.0103296231662647,-9.31082680466162e-05,-0.0100491111257582,-0.0161095316557451,-0.0161468453630935,-0.0104155855088447,-0.00181292737995707,0.00490105475224792,0.00476095922266647,-0.00539373178174549,-0.0252811435926970,-0.0505826702947165,-0.0737496074574140,-0.0860928680247123,-0.0805623627830579,-0.0543218691735667,-0.0102206824722021,0.0434246603068691,0.0947901349225568,0.131716573967150,0.145140989838560,0.131716573967150,0.0947901349225568,0.0434246603068691,-0.0102206824722021,-0.0543218691735667,-0.0805623627830579,-0.0860928680247123,-0.0737496074574140,-0.0505826702947165,-0.0252811435926970,-0.00539373178174549,0.00476095922266647,0.00490105475224792,-0.00181292737995707,-0.0104155855088447,-0.0161468453630935,-0.0161095316557451,-0.0100491111257582,-9.31082680466162e-05,0.0103296231662647,0.0179044612984461,0.0206318293511634,0.0184036150487904,0.0128186591434363,0.00639415629597769,0.00153395497279256,-0.000336309994306555,0.000834459803458931,0.00388808292184370,0.00705638445553241,0.00871848331722897,0.00801189606776569,0.00508316099389093,0.000924775470203202,-0.00309148807118669,-0.00577188463884746,-0.00652571461056274,-0.00551171810403988,-0.00348338043361511,-0.00142876780031817,-0.000167873321602377,-6.69044362889647e-05,-0.000964177179142884,-0.00230873940162444,-0.00343041867033748,-0.00381950579002927,-0.00330641071314688,-0.00208503638292099,-0.000592087600030799,0.000690844072358443,0.00142457039290806,0.00151760259655791,0.00112047634865747,0.000528020447770132,4.19901957069140e-05,-0.000145791262226558,-7.11517274279584e-06,0.000342823119396256,0.000718905391650965,0.000954165973571452,0.000964372863688596,0.000767124547972938,0.000455975615898701,0.000148611327942570,-6.45212572241339e-05};
    
    //BandStop -> Comprimento = 131
    //float kernel[SIZE_FILTER] = {5.10877763248542e-05,-0.000367838960133718,0.000527955895736345,-4.45004521203248e-05,0.000984997480677388,-0.000171763371151433,0.000717233749518247,-0.00105939512837561,4.45681661771805e-05,-0.00171851103347541,0.000269518406600776,-0.00104171957455175,0.00168185197694870,0.000178907578356847,0.00248811192918825,-0.000162922489780466,0.00111182573700691,-0.00221803151968180,-0.000905359713018130,-0.00306491285651843,-0.000407503294790014,-0.000613782816154653,0.00243633197548358,0.00247841946845794,0.00318081558448076,0.00172588004952789,-0.000793296273550805,-0.00212365504572636,-0.00524028681859744,-0.00261185284201444,-0.00401887952608272,0.00339771123691247,0.00118700848886174,0.00945648966361354,0.00128082636344556,0.00736595932599579,-0.00736047229374738,0.000232335238346314,-0.0152677898989250,0.000640539529992584,-0.0116302433845427,0.0126861735904764,-0.00163763874662868,0.0227268470916382,-0.00263534484992956,0.0164366558006659,-0.0193008146099657,0.00199667410420256,-0.0320377034447217,0.00369103868345174,-0.0212125636633604,0.0273879630013498,0.000793911827605862,0.0444237079397578,-0.00173208786701811,0.0252881174758698,-0.0387340359655487,-0.0126427670877019,-0.0664332826810063,-0.0101726633423634,-0.0280343869820019,0.0673875244876939,0.0744880823079128,0.176953799827326,0.165268048568090,0.228858172410980,0.165268048568090,0.176953799827326,0.0744880823079128,0.0673875244876939,-0.0280343869820019,-0.0101726633423634,-0.0664332826810063,-0.0126427670877019,-0.0387340359655487,0.0252881174758698,-0.00173208786701811,0.0444237079397578,0.000793911827605862,0.0273879630013498,-0.0212125636633604,0.00369103868345174,-0.0320377034447217,0.00199667410420256,-0.0193008146099657,0.0164366558006659,-0.00263534484992956,0.0227268470916382,-0.00163763874662868,0.0126861735904764,-0.0116302433845427,0.000640539529992584,-0.0152677898989250,0.000232335238346314,-0.00736047229374738,0.00736595932599579,0.00128082636344556,0.00945648966361354,0.00118700848886174,0.00339771123691247,-0.00401887952608272,-0.00261185284201444,-0.00524028681859744,-0.00212365504572636,-0.000793296273550805,0.00172588004952789,0.00318081558448076,0.00247841946845794,0.00243633197548358,-0.000613782816154653,-0.000407503294790014,-0.00306491285651843,-0.000905359713018130,-0.00221803151968180,0.00111182573700691,-0.000162922489780466,0.00248811192918825,0.000178907578356847,0.00168185197694870,-0.00104171957455175,0.000269518406600776,-0.00171851103347541,4.45681661771805e-05,-0.00105939512837561,0.000717233749518247,-0.000171763371151433,0.000984997480677388,-4.45004521203248e-05,0.000527955895736345,-0.000367838960133718,5.10877763248542e-05};
    
    //HighPass -> Comprimento = 94
    //float kernel[SIZE_FILTER] = {4.01227724664577e-05,-0.000167782198304122,-0.000429326120253317,-0.000675657498154954,-0.000817517711163751,-0.000768802391149324,-0.000475667650593541,5.67498093402328e-05,0.000748968973033203,0.00145061811286626,0.00196608471675002,0.00209982786127197,0.00171248698805039,0.000773944822764225,-0.000602436486101282,-0.00215799724566972,-0.00352655405712756,-0.00430936487814200,-0.00417426812976597,-0.00295705073104293,-0.000738547768745471,0.00212728876350771,0.00505057707259615,0.00731003680427485,0.00821005067286752,0.00725970963341533,0.00433288805939563,-0.000233339643304854,-0.00563610271587199,-0.0107160950761571,-0.0141706963148242,-0.0148370957176820,-0.0119908117497488,-0.00559428875884277,0.00356674002834399,0.0139040006138579,0.0232201279412689,0.0290547839238711,0.0291288534081741,0.0218063579025921,0.00648303898557654,-0.0161816896523085,-0.0442470505068309,-0.0747059604987505,-0.103906319670414,-0.128110319944334,-0.144094007000859,0.850445519444609,-0.144094007000859,-0.128110319944334,-0.103906319670414,-0.0747059604987505,-0.0442470505068309,-0.0161816896523085,0.00648303898557654,0.0218063579025921,0.0291288534081741,0.0290547839238711,0.0232201279412689,0.0139040006138579,0.00356674002834399,-0.00559428875884277,-0.0119908117497488,-0.0148370957176820,-0.0141706963148242,-0.0107160950761571,-0.00563610271587199,-0.000233339643304854,0.00433288805939563,0.00725970963341533,0.00821005067286752,0.00731003680427485,0.00505057707259615,0.00212728876350771,-0.000738547768745471,-0.00295705073104293,-0.00417426812976597,-0.00430936487814200,-0.00352655405712756,-0.00215799724566972,-0.000602436486101282,0.000773944822764225,0.00171248698805039,0.00209982786127197,0.00196608471675002,0.00145061811286626,0.000748968973033203,5.67498093402328e-05,-0.000475667650593541,-0.000768802391149324,-0.000817517711163751,-0.000675657498154954,-0.000429326120253317,-0.000167782198304122,4.01227724664577e-05};
    
    //LowPass -> Comprimento = 94
    float kernel[SIZE_FILTER] = {4.85549801955276e-05,0.000269059076535129,0.000515241829117903,0.000710811686071154,0.000768434499768742,0.000615711111751579,0.000223544346126592,-0.000371605818002960,-0.00106008605097328,-0.00167192116366716,-0.00201113655544415,-0.00190624967627092,-0.00126575173993588,-0.000123619769712573,0.00134029063717875,0.00281602819965297,0.00391859507760781,0.00427507816126844,0.00362654779774916,0.00192021745508576,-0.000634473164502292,-0.00356731853019557,-0.00621649490435005,-0.00785974888136102,-0.00788515291260837,-0.00596525221885145,-0.00219176712414363,0.00286896777725949,0.00822641088584443,0.0126271265285413,0.0148064396731718,0.0137858030559311,0.00915463163107326,0.00127091870104944,-0.00867499957046673,-0.0187654725206108,-0.0266280540009711,-0.0298380380462986,-0.0263822474481865,-0.0150961863591957,0.00401523493053672,0.0296463226632816,0.0592883339779220,0.0895528282263721,0.116672433981882,0.137093992341645,0.148058017223129,0.148058017223129,0.137093992341645,0.116672433981882,0.0895528282263721,0.0592883339779220,0.0296463226632816,0.00401523493053672,-0.0150961863591957,-0.0263822474481865,-0.0298380380462986,-0.0266280540009711,-0.0187654725206108,-0.00867499957046673,0.00127091870104944,0.00915463163107326,0.0137858030559311,0.0148064396731718,0.0126271265285413,0.00822641088584443,0.00286896777725949,-0.00219176712414363,-0.00596525221885145,-0.00788515291260837,-0.00785974888136102,-0.00621649490435005,-0.00356731853019557,-0.000634473164502292,0.00192021745508576,0.00362654779774916,0.00427507816126844,0.00391859507760781,0.00281602819965297,0.00134029063717875,-0.000123619769712573,-0.00126575173993588,-0.00190624967627092,-0.00201113655544415,-0.00167192116366716,-0.00106008605097328,-0.000371605818002960,0.000223544346126592,0.000615711111751579,0.000768434499768742,0.000710811686071154,0.000515241829117903,0.000269059076535129,4.85549801955276e-05};
    
    int result[FRAME_SIZE + SIZE_FILTER - 1];

	while(1)
	{
			/* Obtaing the ADC samples	*/
			while(ADCChannelIsBusy(pADCChannelHandle));
                ADCChannelRead(pADCChannelHandle,samples,FRAME_SIZE);           
                        
            while(OCPWMIsBusy(pOCPWMHandle));
                convolution(samples, kernel, result, FRAME_SIZE, SIZE_FILTER, FRAME_SIZE + SIZE_FILTER - 1);

		
			/* Write the frame to the output	*/
            OCPWMWrite(pOCPWMHandle, result, FRAME_SIZE);
			/* Playback the intro message if record or play functions 
			 * are not active. Read SFM from address 0 where the intro
			 * message is stored. Rewind the currentReadAddress if the
			 * message has reached the end.
			 * */
	}
}

void convolution(int signal[], float kernel[], int result[], int size_signal, int size_kernel, int size_result) {
    int i, j;
    float resultFloat[size_result];
    for (i = 0; i < size_result; i++) {
        resultFloat[i] = 0;
        for (j = 0; j < size_signal ; j++) {
            if (i - j >= 0 && i - j < size_kernel) {
                resultFloat[i] += signal[j] * kernel[i - j];
            }
        }
    }
    for (i = 0; i<size_result;i++){
        result[i] = (int) resultFloat[i];
    }
}